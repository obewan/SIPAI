<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>SIPAI: sipai Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">SIPAI
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">sipai Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsipai_1_1AppParams.html">AppParams</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1Connection.html">Connection</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1EmptyCellException.html">EmptyCellException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsipai_1_1EmptyCellException.html" title="EmptyCellException.">EmptyCellException</a>.  <a href="classsipai_1_1EmptyCellException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1FileReaderException.html">FileReaderException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom exception class that inherits from std::exception. This class is thrown when there are issues with file reader operations.  <a href="classsipai_1_1FileReaderException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1ImageExportException.html">ImageExportException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom exception class that inherits from std::exception. This class is thrown when there are issues with image export operations.  <a href="classsipai_1_1ImageExportException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1ImageHelperException.html">ImageHelperException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom exception class that inherits from std::exception. This class is thrown when there are issues with image operations.  <a href="classsipai_1_1ImageHelperException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1ImportExportException.html">ImportExportException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom exception class that inherits from std::exception. This class is thrown when there are issues with neural Import/Export operations.  <a href="classsipai_1_1ImportExportException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1ManagerException.html">ManagerException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom exception class that inherits from std::exception. This class is thrown when there are issues with manager operations.  <a href="classsipai_1_1ManagerException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1NetworkException.html">NetworkException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A custom exception class that inherits from std::exception. This class is thrown when there are issues with neural Network operations.  <a href="classsipai_1_1NetworkException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1HiddenLayer.html">HiddenLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classsipai_1_1HiddenLayer.html" title="The HiddenLayer class represents a hidden layer in a neural network. It inherits from the Layer class...">HiddenLayer</a> class represents a hidden layer in a neural network. It inherits from the <a class="el" href="classsipai_1_1Layer.html" title="The Layer class represents a layer in a neural network. It contains a vector of Neurons and has metho...">Layer</a> class and overrides its methods as necessary. Hidden layers are responsible for processing inputs received from the input layer and passing the result to the output layer or the next hidden layer.  <a href="classsipai_1_1HiddenLayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1ImageExport.html">ImageExport</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1ImageHelper.html">ImageHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1InputLayer.html">InputLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classsipai_1_1InputLayer.html" title="The InputLayer class represents the input layer of a neural network. It inherits from the Layer class...">InputLayer</a> class represents the input layer of a neural network. It inherits from the <a class="el" href="classsipai_1_1Layer.html" title="The Layer class represents a layer in a neural network. It contains a vector of Neurons and has metho...">Layer</a> class and overrides its methods as necessary. This layer is responsible for receiving input from external sources.  <a href="classsipai_1_1InputLayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1Layer.html">Layer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classsipai_1_1Layer.html" title="The Layer class represents a layer in a neural network. It contains a vector of Neurons and has metho...">Layer</a> class represents a layer in a neural network. It contains a vector of Neurons and has methods for forward propagation, backward propagation, and updating weights.  <a href="classsipai_1_1Layer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1Manager.html">Manager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1NeuralNetwork.html">NeuralNetwork</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class represents a neural network for image processing.  <a href="classsipai_1_1NeuralNetwork.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1NeuralNetworkImportExport.html">NeuralNetworkImportExport</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1NeuralNetworkImportExportCSV.html">NeuralNetworkImportExportCSV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1NeuralNetworkImportExportJSON.html">NeuralNetworkImportExportJSON</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">NetworkImportExportJSON class to export and import network models using the JSON format.  <a href="classsipai_1_1NeuralNetworkImportExportJSON.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsipai_1_1NeuralNetworkParams.html">NeuralNetworkParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for the neural Network.  <a href="structsipai_1_1NeuralNetworkParams.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1Neuron.html">Neuron</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classsipai_1_1Neuron.html" title="The Neuron class represents a neuron in a neural network. It contains a value, bias,...">Neuron</a> class represents a neuron in a neural network. It contains a value, bias, error, and a vector of weights. It also has methods for initializing weights.  <a href="classsipai_1_1Neuron.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1OutputLayer.html">OutputLayer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="classsipai_1_1OutputLayer.html" title="The OutputLayer class represents the output layer of a neural network. It inherits from the Layer cla...">OutputLayer</a> class represents the output layer of a neural network. It inherits from the <a class="el" href="classsipai_1_1Layer.html" title="The Layer class represents a layer in a neural network. It contains a vector of Neurons and has metho...">Layer</a> class and overrides its methods as necessary. This layer is responsible for producing the final output of the network.  <a href="classsipai_1_1OutputLayer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsipai_1_1RGBA.html">RGBA</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1RunnerVisitor.html">RunnerVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1SimpleLogger.html">SimpleLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classsipai_1_1SimpleLogger.html" title="SimpleLogger class.">SimpleLogger</a> class.  <a href="classsipai_1_1SimpleLogger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1TrainingDataFileReaderCSV.html">TrainingDataFileReaderCSV</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsipai_1_1TrainingMonitoredVisitor.html">TrainingMonitoredVisitor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a64e0bb44a4af191b5e765f04ba8cefca"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a64e0bb44a4af191b5e765f04ba8cefca">TrainingData</a> = std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;</td></tr>
<tr class="separator:a64e0bb44a4af191b5e765f04ba8cefca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a181631bc0a7b2f9f16ccea79d30c7194"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a181631bc0a7b2f9f16ccea79d30c7194">EActivationFunction</a> { <br />
&#160;&#160;<a class="el" href="namespacesipai.html#a181631bc0a7b2f9f16ccea79d30c7194a5b44c930bf0ddeef48b50ef11e5ddd58">ELU</a>
, <a class="el" href="namespacesipai.html#a181631bc0a7b2f9f16ccea79d30c7194a601049e29a4481e658f6745a54aa3ad9">LReLU</a>
, <a class="el" href="namespacesipai.html#a181631bc0a7b2f9f16ccea79d30c7194a474e0c94ac3a455d2b98a72feba8fba4">PReLU</a>
, <a class="el" href="namespacesipai.html#a181631bc0a7b2f9f16ccea79d30c7194add10d919fa85cf27fc78c0e06fe0b378">ReLU</a>
, <br />
&#160;&#160;<a class="el" href="namespacesipai.html#a181631bc0a7b2f9f16ccea79d30c7194a21eebb164e4b8b9bcf64fdb4d8d5dff4">Sigmoid</a>
, <a class="el" href="namespacesipai.html#a181631bc0a7b2f9f16ccea79d30c7194acc132a41cab5676334f353a22a0aa5c5">Tanh</a>
<br />
 }</td></tr>
<tr class="memdesc:a181631bc0a7b2f9f16ccea79d30c7194"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activation Function enum.  <a href="namespacesipai.html#a181631bc0a7b2f9f16ccea79d30c7194">More...</a><br /></td></tr>
<tr class="separator:a181631bc0a7b2f9f16ccea79d30c7194"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86f53af3a527e290419e10fd371cd032"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a86f53af3a527e290419e10fd371cd032">ERunMode</a> { <a class="el" href="namespacesipai.html#a86f53af3a527e290419e10fd371cd032a235ff0497734d85587533ff1ae6aa26b">Enhancer</a>
, <a class="el" href="namespacesipai.html#a86f53af3a527e290419e10fd371cd032afa6a5a3224d7da66d9e0bdec25f62cf0">Testing</a>
, <a class="el" href="namespacesipai.html#a86f53af3a527e290419e10fd371cd032acf270e40d273f9e7fd7c3061729060c3">Training</a>
, <a class="el" href="namespacesipai.html#a86f53af3a527e290419e10fd371cd032ad8bd04dc25b6c9e78730ad78cbd8d074">TrainingMonitored</a>
 }</td></tr>
<tr class="separator:a86f53af3a527e290419e10fd371cd032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49db076f4fbba89b129c17e422f06824"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a49db076f4fbba89b129c17e422f06824">LayerType</a> { <a class="el" href="namespacesipai.html#a49db076f4fbba89b129c17e422f06824ae19b8d69e381495ab2dcfad0f947c5de">InputLayer</a>
, <a class="el" href="namespacesipai.html#a49db076f4fbba89b129c17e422f06824a1462c81ba3769d8f4a5a20fcf19af10d">HiddenLayer</a>
, <a class="el" href="namespacesipai.html#a49db076f4fbba89b129c17e422f06824a500cef5499f984f348ea5eabd57ee667">OutputLayer</a>
 }</td></tr>
<tr class="separator:a49db076f4fbba89b129c17e422f06824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef9a32a9573d0356a88a9325b5551a0"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a8ef9a32a9573d0356a88a9325b5551a0">LogLevel</a> { <a class="el" href="namespacesipai.html#a8ef9a32a9573d0356a88a9325b5551a0a551b723eafd6a31d444fcb2f5920fbd3">INFO</a>
, <a class="el" href="namespacesipai.html#a8ef9a32a9573d0356a88a9325b5551a0a32bd8a1db2275458673903bdb84cb277">WARN</a>
, <a class="el" href="namespacesipai.html#a8ef9a32a9573d0356a88a9325b5551a0abb1ca97ec761fc37101737ba0aa2e7c5">ERROR</a>
, <a class="el" href="namespacesipai.html#a8ef9a32a9573d0356a88a9325b5551a0adc30ec20708ef7b0f641ef78b7880a15">DEBUG</a>
 }</td></tr>
<tr class="separator:a8ef9a32a9573d0356a88a9325b5551a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7acc8cad3ad16468ff3ad375bd0e7408"><td class="memItemLeft" align="right" valign="top">consteval unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a7acc8cad3ad16468ff3ad375bd0e7408">operator&quot;&quot;_K</a> (unsigned long long x)</td></tr>
<tr class="separator:a7acc8cad3ad16468ff3ad375bd0e7408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a530b8bee6048178fc409bf40934c4505"><td class="memItemLeft" align="right" valign="top">consteval unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a530b8bee6048178fc409bf40934c4505">operator&quot;&quot;_M</a> (unsigned long long x)</td></tr>
<tr class="separator:a530b8bee6048178fc409bf40934c4505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae718ee7f1d5973fe0c098517fef3d66f"><td class="memItemLeft" align="right" valign="top">consteval unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#ae718ee7f1d5973fe0c098517fef3d66f">operator&quot;&quot;_G</a> (unsigned long long x)</td></tr>
<tr class="separator:ae718ee7f1d5973fe0c098517fef3d66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:acecdfef9c16fa14e9921e2aaca700fb0"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="namespacesipai.html#a181631bc0a7b2f9f16ccea79d30c7194">EActivationFunction</a>, std::less&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#acecdfef9c16fa14e9921e2aaca700fb0">activation_map</a></td></tr>
<tr class="separator:acecdfef9c16fa14e9921e2aaca700fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d64288ca760fc3e1b426c80aa0e7534"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a5d64288ca760fc3e1b426c80aa0e7534">sigmoid</a> = [](auto x) { return 1.0f / (1.0f + exp(-x)); }</td></tr>
<tr class="memdesc:a5d64288ca760fc3e1b426c80aa0e7534"><td class="mdescLeft">&#160;</td><td class="mdescRight">the sigmoid function is commonly used as the activation function during the forward propagation step. The reason for this is that the sigmoid function maps any input value into a range between 0 and 1, which can be useful for outputting probabilities, among other things. The sigmoid derivative can be expressed in terms of the output of the sigmoid function itself: if σ(x) is the sigmoid function, then its derivative σ'(x) can be computed as σ(x) * (1 - σ(x)).  <a href="namespacesipai.html#a5d64288ca760fc3e1b426c80aa0e7534">More...</a><br /></td></tr>
<tr class="separator:a5d64288ca760fc3e1b426c80aa0e7534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ea4c9552c815ccdfec85f5c297997b"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#ac5ea4c9552c815ccdfec85f5c297997b">sigmoidDerivative</a></td></tr>
<tr class="separator:ac5ea4c9552c815ccdfec85f5c297997b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703f16daca81e1a86081c4582ef042ba"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a703f16daca81e1a86081c4582ef042ba">tanhFunc</a> = [](auto x) { return tanh(x); }</td></tr>
<tr class="memdesc:a703f16daca81e1a86081c4582ef042ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tanh Function (Hyperbolic Tangent): This function is similar to the sigmoid function but maps the input to a range between -1 and 1. It is often used in the hidden layers of a neural network.  <a href="namespacesipai.html#a703f16daca81e1a86081c4582ef042ba">More...</a><br /></td></tr>
<tr class="separator:a703f16daca81e1a86081c4582ef042ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83037f4cb7a18c26eaed42312d656812"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a83037f4cb7a18c26eaed42312d656812">tanhDerivative</a></td></tr>
<tr class="separator:a83037f4cb7a18c26eaed42312d656812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ca1a408822f4824a7cc57802e3f73a"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#ac4ca1a408822f4824a7cc57802e3f73a">relu</a> = [](auto x) { return std::max(0.0f, x); }</td></tr>
<tr class="memdesc:ac4ca1a408822f4824a7cc57802e3f73a"><td class="mdescLeft">&#160;</td><td class="mdescRight">ReLU Function (Rectified Linear Unit): This function outputs the input directly if it’s positive; otherwise, it outputs zero. It has become very popular in recent years because it helps to alleviate the vanishing gradient problem.  <a href="namespacesipai.html#ac4ca1a408822f4824a7cc57802e3f73a">More...</a><br /></td></tr>
<tr class="separator:ac4ca1a408822f4824a7cc57802e3f73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f01a2b99895a061124a4d1732708f8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#ac9f01a2b99895a061124a4d1732708f8">reluDerivative</a> = [](auto x) { return x &gt; 0 ? 1.0f : 0.0f; }</td></tr>
<tr class="separator:ac9f01a2b99895a061124a4d1732708f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6ea0e8c02ae320758bf298c6749eac"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a3d6ea0e8c02ae320758bf298c6749eac">leakyRelu</a> = [](auto x) { return std::max(0.01f * x, x); }</td></tr>
<tr class="memdesc:a3d6ea0e8c02ae320758bf298c6749eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Leaky ReLU: This is a variant of ReLU that allows small negative values when the input is less than zero. It can help to alleviate the dying ReLU problem where neurons become inactive and only output zero.  <a href="namespacesipai.html#a3d6ea0e8c02ae320758bf298c6749eac">More...</a><br /></td></tr>
<tr class="separator:a3d6ea0e8c02ae320758bf298c6749eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854697817659f1a4862b24cfc652289e"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a854697817659f1a4862b24cfc652289e">leakyReluDerivative</a> = [](auto x) { return x &gt; 0 ? 1.0f : 0.01f; }</td></tr>
<tr class="separator:a854697817659f1a4862b24cfc652289e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1054f011782057a93919baf09a141879"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a1054f011782057a93919baf09a141879">parametricRelu</a></td></tr>
<tr class="memdesc:a1054f011782057a93919baf09a141879"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parametric ReLU (PReLU) is a type of leaky ReLU that, instead of having a predetermined slope like 0.01, learns the slope during training. This can give it a bit more flexibility and help it to learn more complex patterns.  <a href="namespacesipai.html#a1054f011782057a93919baf09a141879">More...</a><br /></td></tr>
<tr class="separator:a1054f011782057a93919baf09a141879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07bcbe09fe9ab29378d50150b61cd3b8"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a07bcbe09fe9ab29378d50150b61cd3b8">parametricReluDerivative</a></td></tr>
<tr class="separator:a07bcbe09fe9ab29378d50150b61cd3b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ab2586c52d0cb588fd3f25766c7c13"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a59ab2586c52d0cb588fd3f25766c7c13">elu</a></td></tr>
<tr class="memdesc:a59ab2586c52d0cb588fd3f25766c7c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">the Exponential Linear Units (ELUs) are a great choice as they take on negative values when the input is less than zero, which allows them to push mean unit activations closer to zero like batch normalization. Unlike ReLUs, ELUs have a nonzero gradient for negative input, which avoids the “dead neuron” problem.  <a href="namespacesipai.html#a59ab2586c52d0cb588fd3f25766c7c13">More...</a><br /></td></tr>
<tr class="separator:a59ab2586c52d0cb588fd3f25766c7c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d20ea3c7b78d0f33fb012b2192e7c7"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a52d20ea3c7b78d0f33fb012b2192e7c7">eluDerivative</a></td></tr>
<tr class="separator:a52d20ea3c7b78d0f33fb012b2192e7c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56e9fa2be87cd2f76b7c37721c94cb44"><td class="memItemLeft" align="right" valign="top">constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a56e9fa2be87cd2f76b7c37721c94cb44">NOMAX_EPOCHS</a> = -1</td></tr>
<tr class="separator:a56e9fa2be87cd2f76b7c37721c94cb44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c1adef9985b74cdf2ec4d38f18b0a38"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="namespacesipai.html#a86f53af3a527e290419e10fd371cd032">ERunMode</a>, std::less&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#a8c1adef9985b74cdf2ec4d38f18b0a38">mode_map</a></td></tr>
<tr class="separator:a8c1adef9985b74cdf2ec4d38f18b0a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d5df6a1588c2cba272a4e4dccd8ab3"><td class="memItemLeft" align="right" valign="top">const std::map&lt; std::string, <a class="el" href="namespacesipai.html#a49db076f4fbba89b129c17e422f06824">LayerType</a>, std::less&lt;&gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesipai.html#ae0d5df6a1588c2cba272a4e4dccd8ab3">layer_map</a></td></tr>
<tr class="separator:ae0d5df6a1588c2cba272a4e4dccd8ab3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a64e0bb44a4af191b5e765f04ba8cefca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64e0bb44a4af191b5e765f04ba8cefca">&#9670;&nbsp;</a></span>TrainingData</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesipai.html#a64e0bb44a4af191b5e765f04ba8cefca">sipai::TrainingData</a> = typedef std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a181631bc0a7b2f9f16ccea79d30c7194"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181631bc0a7b2f9f16ccea79d30c7194">&#9670;&nbsp;</a></span>EActivationFunction</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesipai.html#a181631bc0a7b2f9f16ccea79d30c7194">sipai::EActivationFunction</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activation Function enum. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a181631bc0a7b2f9f16ccea79d30c7194a5b44c930bf0ddeef48b50ef11e5ddd58"></a>ELU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a181631bc0a7b2f9f16ccea79d30c7194a601049e29a4481e658f6745a54aa3ad9"></a>LReLU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a181631bc0a7b2f9f16ccea79d30c7194a474e0c94ac3a455d2b98a72feba8fba4"></a>PReLU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a181631bc0a7b2f9f16ccea79d30c7194add10d919fa85cf27fc78c0e06fe0b378"></a>ReLU&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a181631bc0a7b2f9f16ccea79d30c7194a21eebb164e4b8b9bcf64fdb4d8d5dff4"></a>Sigmoid&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a181631bc0a7b2f9f16ccea79d30c7194acc132a41cab5676334f353a22a0aa5c5"></a>Tanh&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a86f53af3a527e290419e10fd371cd032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86f53af3a527e290419e10fd371cd032">&#9670;&nbsp;</a></span>ERunMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesipai.html#a86f53af3a527e290419e10fd371cd032">sipai::ERunMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a86f53af3a527e290419e10fd371cd032a235ff0497734d85587533ff1ae6aa26b"></a>Enhancer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a86f53af3a527e290419e10fd371cd032afa6a5a3224d7da66d9e0bdec25f62cf0"></a>Testing&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a86f53af3a527e290419e10fd371cd032acf270e40d273f9e7fd7c3061729060c3"></a>Training&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a86f53af3a527e290419e10fd371cd032ad8bd04dc25b6c9e78730ad78cbd8d074"></a>TrainingMonitored&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a49db076f4fbba89b129c17e422f06824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49db076f4fbba89b129c17e422f06824">&#9670;&nbsp;</a></span>LayerType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesipai.html#a49db076f4fbba89b129c17e422f06824">sipai::LayerType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a49db076f4fbba89b129c17e422f06824ae19b8d69e381495ab2dcfad0f947c5de"></a>InputLayer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a49db076f4fbba89b129c17e422f06824a1462c81ba3769d8f4a5a20fcf19af10d"></a>HiddenLayer&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a49db076f4fbba89b129c17e422f06824a500cef5499f984f348ea5eabd57ee667"></a>OutputLayer&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a8ef9a32a9573d0356a88a9325b5551a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef9a32a9573d0356a88a9325b5551a0">&#9670;&nbsp;</a></span>LogLevel</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesipai.html#a8ef9a32a9573d0356a88a9325b5551a0">sipai::LogLevel</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8ef9a32a9573d0356a88a9325b5551a0a551b723eafd6a31d444fcb2f5920fbd3"></a>INFO&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8ef9a32a9573d0356a88a9325b5551a0a32bd8a1db2275458673903bdb84cb277"></a>WARN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8ef9a32a9573d0356a88a9325b5551a0abb1ca97ec761fc37101737ba0aa2e7c5"></a>ERROR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8ef9a32a9573d0356a88a9325b5551a0adc30ec20708ef7b0f641ef78b7880a15"></a>DEBUG&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae718ee7f1d5973fe0c098517fef3d66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae718ee7f1d5973fe0c098517fef3d66f">&#9670;&nbsp;</a></span>operator&quot;&quot;_G()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">consteval unsigned long long sipai::operator&quot;&quot;_G </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7acc8cad3ad16468ff3ad375bd0e7408"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acc8cad3ad16468ff3ad375bd0e7408">&#9670;&nbsp;</a></span>operator&quot;&quot;_K()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">consteval unsigned long long sipai::operator&quot;&quot;_K </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a530b8bee6048178fc409bf40934c4505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a530b8bee6048178fc409bf40934c4505">&#9670;&nbsp;</a></span>operator&quot;&quot;_M()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">consteval unsigned long long sipai::operator&quot;&quot;_M </td>
          <td>(</td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="acecdfef9c16fa14e9921e2aaca700fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acecdfef9c16fa14e9921e2aaca700fb0">&#9670;&nbsp;</a></span>activation_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, <a class="el" href="namespacesipai.html#a181631bc0a7b2f9f16ccea79d30c7194">EActivationFunction</a>, std::less&lt;&gt; &gt; sipai::activation_map</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    {<span class="stringliteral">&quot;ELU&quot;</span>, EActivationFunction::ELU},</div>
<div class="line">    {<span class="stringliteral">&quot;LReLU&quot;</span>, EActivationFunction::LReLU},</div>
<div class="line">    {<span class="stringliteral">&quot;PReLU&quot;</span>, EActivationFunction::PReLU},</div>
<div class="line">    {<span class="stringliteral">&quot;ReLU&quot;</span>, EActivationFunction::ReLU},</div>
<div class="line">    {<span class="stringliteral">&quot;Sigmoid&quot;</span>, EActivationFunction::Sigmoid},</div>
<div class="line">    {<span class="stringliteral">&quot;Tanh&quot;</span>, EActivationFunction::Tanh}}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a59ab2586c52d0cb588fd3f25766c7c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ab2586c52d0cb588fd3f25766c7c13">&#9670;&nbsp;</a></span>elu</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sipai::elu</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> alpha) {</div>
<div class="line">  <span class="keywordflow">return</span> x &gt;= 0 ? x : alpha * (exp(x) - 1);</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>the Exponential Linear Units (ELUs) are a great choice as they take on negative values when the input is less than zero, which allows them to push mean unit activations closer to zero like batch normalization. Unlike ReLUs, ELUs have a nonzero gradient for negative input, which avoids the “dead neuron” problem. </p>

</div>
</div>
<a id="a52d20ea3c7b78d0f33fb012b2192e7c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d20ea3c7b78d0f33fb012b2192e7c7">&#9670;&nbsp;</a></span>eluDerivative</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sipai::eluDerivative</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> alpha) {</div>
<div class="line">  <span class="keywordflow">return</span> x &gt;= 0 ? 1 : alpha * exp(x);</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ae0d5df6a1588c2cba272a4e4dccd8ab3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0d5df6a1588c2cba272a4e4dccd8ab3">&#9670;&nbsp;</a></span>layer_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, <a class="el" href="namespacesipai.html#a49db076f4fbba89b129c17e422f06824">LayerType</a>, std::less&lt;&gt; &gt; sipai::layer_map</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    {<span class="stringliteral">&quot;InputLayer&quot;</span>, LayerType::InputLayer},</div>
<div class="line">    {<span class="stringliteral">&quot;HiddenLayer&quot;</span>, LayerType::HiddenLayer},</div>
<div class="line">    {<span class="stringliteral">&quot;OutputLayer&quot;</span>, LayerType::OutputLayer}}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a3d6ea0e8c02ae320758bf298c6749eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6ea0e8c02ae320758bf298c6749eac">&#9670;&nbsp;</a></span>leakyRelu</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sipai::leakyRelu = [](auto x) { return std::max(0.01f * x, x); }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Leaky ReLU: This is a variant of ReLU that allows small negative values when the input is less than zero. It can help to alleviate the dying ReLU problem where neurons become inactive and only output zero. </p>

</div>
</div>
<a id="a854697817659f1a4862b24cfc652289e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854697817659f1a4862b24cfc652289e">&#9670;&nbsp;</a></span>leakyReluDerivative</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sipai::leakyReluDerivative = [](auto x) { return x &gt; 0 ? 1.0f : 0.01f; }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c1adef9985b74cdf2ec4d38f18b0a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c1adef9985b74cdf2ec4d38f18b0a38">&#9670;&nbsp;</a></span>mode_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::map&lt;std::string, <a class="el" href="namespacesipai.html#a86f53af3a527e290419e10fd371cd032">ERunMode</a>, std::less&lt;&gt; &gt; sipai::mode_map</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div>
<div class="line">    {<span class="stringliteral">&quot;Enhancer&quot;</span>, ERunMode::Enhancer},</div>
<div class="line">    {<span class="stringliteral">&quot;Testing&quot;</span>, ERunMode::Testing},</div>
<div class="line">    {<span class="stringliteral">&quot;Training&quot;</span>, ERunMode::Training},</div>
<div class="line">    {<span class="stringliteral">&quot;TrainingMonitored&quot;</span>, ERunMode::TrainingMonitored}}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a56e9fa2be87cd2f76b7c37721c94cb44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56e9fa2be87cd2f76b7c37721c94cb44">&#9670;&nbsp;</a></span>NOMAX_EPOCHS</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int sipai::NOMAX_EPOCHS = -1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1054f011782057a93919baf09a141879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1054f011782057a93919baf09a141879">&#9670;&nbsp;</a></span>parametricRelu</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sipai::parametricRelu</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> alpha) {</div>
<div class="line">  <span class="keywordflow">return</span> std::max(alpha * x, x);</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>Parametric ReLU (PReLU) is a type of leaky ReLU that, instead of having a predetermined slope like 0.01, learns the slope during training. This can give it a bit more flexibility and help it to learn more complex patterns. </p>

</div>
</div>
<a id="a07bcbe09fe9ab29378d50150b61cd3b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07bcbe09fe9ab29378d50150b61cd3b8">&#9670;&nbsp;</a></span>parametricReluDerivative</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sipai::parametricReluDerivative</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> x, <span class="keyword">auto</span> alpha) {</div>
<div class="line">  <span class="keywordflow">return</span> x &gt; 0 ? 1.0f : alpha;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="ac4ca1a408822f4824a7cc57802e3f73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ca1a408822f4824a7cc57802e3f73a">&#9670;&nbsp;</a></span>relu</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sipai::relu = [](auto x) { return std::max(0.0f, x); }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>ReLU Function (Rectified Linear Unit): This function outputs the input directly if it’s positive; otherwise, it outputs zero. It has become very popular in recent years because it helps to alleviate the vanishing gradient problem. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Unit</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>ReLU </dd></dl>

</div>
</div>
<a id="ac9f01a2b99895a061124a4d1732708f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f01a2b99895a061124a4d1732708f8">&#9670;&nbsp;</a></span>reluDerivative</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sipai::reluDerivative = [](auto x) { return x &gt; 0 ? 1.0f : 0.0f; }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d64288ca760fc3e1b426c80aa0e7534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d64288ca760fc3e1b426c80aa0e7534">&#9670;&nbsp;</a></span>sigmoid</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sipai::sigmoid = [](auto x) { return 1.0f / (1.0f + exp(-x)); }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the sigmoid function is commonly used as the activation function during the forward propagation step. The reason for this is that the sigmoid function maps any input value into a range between 0 and 1, which can be useful for outputting probabilities, among other things. The sigmoid derivative can be expressed in terms of the output of the sigmoid function itself: if σ(x) is the sigmoid function, then its derivative σ'(x) can be computed as σ(x) * (1 - σ(x)). </p>

</div>
</div>
<a id="ac5ea4c9552c815ccdfec85f5c297997b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5ea4c9552c815ccdfec85f5c297997b">&#9670;&nbsp;</a></span>sigmoidDerivative</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sipai::sigmoidDerivative</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> x) {</div>
<div class="line">  <span class="keywordtype">float</span> sigmoidValue = <a class="code" href="namespacesipai.html#a5d64288ca760fc3e1b426c80aa0e7534">sigmoid</a>(x);</div>
<div class="line">  <span class="keywordflow">return</span> sigmoidValue * (1 - sigmoidValue);</div>
<div class="line">}</div>
<div class="ttc" id="anamespacesipai_html_a5d64288ca760fc3e1b426c80aa0e7534"><div class="ttname"><a href="namespacesipai.html#a5d64288ca760fc3e1b426c80aa0e7534">sipai::sigmoid</a></div><div class="ttdeci">auto sigmoid</div><div class="ttdoc">the sigmoid function is commonly used as the activation function during the forward propagation step....</div><div class="ttdef"><b>Definition:</b> ActivationFunctions.h:40</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a83037f4cb7a18c26eaed42312d656812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83037f4cb7a18c26eaed42312d656812">&#9670;&nbsp;</a></span>tanhDerivative</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sipai::tanhDerivative</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span> x) {</div>
<div class="line">  <span class="keywordtype">float</span> tanhValue = tanh(x);</div>
<div class="line">  <span class="keywordflow">return</span> 1 - tanhValue * tanhValue;</div>
<div class="line">}</div>
</div><!-- fragment -->
</div>
</div>
<a id="a703f16daca81e1a86081c4582ef042ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703f16daca81e1a86081c4582ef042ba">&#9670;&nbsp;</a></span>tanhFunc</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto sipai::tanhFunc = [](auto x) { return tanh(x); }</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tanh Function (Hyperbolic Tangent): This function is similar to the sigmoid function but maps the input to a range between -1 and 1. It is often used in the hidden layers of a neural network. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
